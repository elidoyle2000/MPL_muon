# -*- coding: utf-8 -*-
"""PHYS2010 Muon - Examples of Analysis of Pulse Heights Histograms and Correlations of Heights in Channels Scatter Plots.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yddqwbPkQhH6UWOcW4rZe_t97yp_x86V

#PHYS2010 Muon Decay Experiment - More advanced examples of how to extract histograms of pulse heights from the data

190619 v1.0 Jeanne Bang Transferred JB code from Jupyter. Plots of processed data<br>
190621 v1.1 Gaitskell made additional plots<br>
191004 v2.0 Gaitskell Made new notebook (this one, but based on one linked at end of this notebook) which gives preliminary analysis example for students doing the course <br>
191017 v2.1 Gaitskell Additional help information <br>
220201 v2.2 Gaitskell Mods for clarity <br>

<b> This example file should not be copied verbetim. It is provided to students to give you an example of what is possible with your own analysis code</b>

The data file that is loaded contains peak heights and times that have been calculated from the time traces (recorded from the Picoscope) in a separate piece of Python Code

Also note that the trigger threshold in this particular dataset was set TOO LOW for taking long multiday datasets since it will include many gamma events as well as muon events. You will need to decide where an optimal trigger threshold is for longer term data.

Ch0 (A) is left middle PMT (trigger)<br>
Ch1 (B) is right middle PMT<br>
Ch2 (C) Top Paddle<br>
Ch3 (D) Bottom Paddle<br>


# Load Muon Data and Make Preliminary Plots

## Setup
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

"""### Functions to help with histogram bins"""

# For Histograms binning. Gaitskell 190620
# Will pass int through, otherwise if a numpy array of n centers gives n-1 edges, or n+1 edges if includes +/- inf

def binEdgesFromCenters( binCenters=20 , infEdges=False): 
  if isinstance( binCenters , int):
    # Integer, so pass it through
    binEdges = binCenters
  else:
    binEdges = binCenters[:-1]+np.diff(binCenters)/2.
  # The reverse is    binsCenters  = (binEdges[:-1]+binEdges[1:]) / 2.
    if infEdges:
      binEdges = np.concatenate( (np.array([-np.inf]),binEdges,np.array([np.inf])) )
  return( binEdges )
  
 
def binCentersFromEdges( binEdges=20 ): 
  if isinstance( binEdges , int):
    # Integer, so pass it through
    binCenters = binEdges
  else:
    binCenters = (binEdges[:-1] + binEdges[1:])/2.
  return( binCenters )

# e.g. binEdgesFromCenters( np.array([1,2,3,4]) , infEdges = True )
#   gives   array([-inf,  1.5,  2.5,  3.5,  inf])

"""## Load Data"""

mu = np.load('full_muon_data.npz')



"""
Ch0 (A) is left middle PMT (trigger)<br>
Ch1 (B) is right middle PMT<br>
Ch2 (C) Top Paddle<br>
Ch3 (D) Bottom Paddle<br>
"""

# Look at the contents
print( '            shape is (event , channel number)' )
for k in mu.keys():
    print("%-15s, shape = %s"%(k,mu[k].shape))

# Extract Data from npz file into variables
#   These values were calculated by separate code from the time traces in each channel
#
peakHeight1 = mu['peak1_heights'] # First peak in trace
peakHeight2 = mu['peak2_heights'] # Second peak in trace if there is one
peakWhere1 = mu['peak1_times'] # Time in us
peakWhere2 = mu['peak2_times'] # Time in us
# peakAreaTotal = mu['peakAreaTotal']
# peakTimeDiff = mu['peakWhere2'] - mu['peakWhere1']

# What is the latest time for a peak?
np.max( peakWhere2[:,0] ) # us

peakWhere1[0,:]

# Plot a histogram of the data

# Times are in us
binWidth = 0.8 # us 
binsCenters = np.linspace(-1.,20.,1+int(21./binWidth))
binsEdges = binEdgesFromCenters( binCenters=binsCenters , infEdges=False)

plt.figure( figsize = (10,7))

# These figures include hostogram and error bars calculated from the sqrt(number of counts)
# You can ignore the patches values
y , bins , patches = plt.hist( peakWhere1[:,0] , bins=binsEdges , color='red' , histtype = 'step' , log=True , linewidth=2. , label='Time 1')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'red' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakWhere2[:,0] , bins=binsEdges , color='blue' , histtype = 'step' , log=True , linewidth=2. , label='Time 2')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'blue' , elinewidth=0.5 , fmt='none' );

plt.ylim(top=6.e3,bottom=0.8)
#plt.xlim(left=1.5,right=1.7)

plt.title('Peak Times from Muon Data')
plt.xlabel('Time Peak (us)')
plt.ylabel('Counts / bin')
plt.grid()

plt.legend()

# Plot a histogram of the data

# Times are in us
binsEdges = 100

plt.figure( figsize = (10,7))

y , bins , patches = plt.hist( peakHeight1[:,0] , bins=binsEdges , color='red' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk1 Ch0')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'red' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight1[:,1] , bins=binsEdges , color='blue' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk1 Ch1')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'blue' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight1[:,2] , bins=binsEdges , color='green' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk1 Ch2')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'green' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight1[:,3] , bins=binsEdges , color='cyan' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk1 Ch3')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'cyan' , elinewidth=0.5 , fmt='none' );

plt.ylim(top=6.e4,bottom=0.8)
#plt.xlim(left=1.5,right=1.7)

plt.xlabel('Peak Height (AU)')
plt.ylabel('Counts / bin')
plt.grid()

plt.legend();

# Plot a histogram of the data

# Times are in us
binsEdges = 100


plt.figure( figsize = (10,7))

y , bins , patches = plt.hist( peakHeight2[:,0] , bins=binsEdges , color='red' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk2 Ch0')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'red' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight2[:,1] , bins=binsEdges , color='blue' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk2 Ch1')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'blue' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight2[:,2] , bins=binsEdges , color='green' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk2 Ch2')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'green' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight2[:,3] , bins=binsEdges , color='cyan' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk2 Ch3')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'cyan' , elinewidth=0.5 , fmt='none' );

plt.ylim(top=6.e4,bottom=0.8)
#plt.xlim(left=1.5,right=1.7)

plt.xlabel('Peak Height (AU)')
plt.ylabel('Counts / bin')
plt.grid()

plt.legend();

# Plot a histogram of the data

# Times are in us
binsEdges = 100


plt.figure( figsize = (10,7))

y , bins , patches = plt.hist( peakHeight1[:,0] , bins=binsEdges , color='red' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk1 Ch0')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'red' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight1[:,1] , bins=binsEdges , color='blue' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk1 Ch1')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'blue' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight2[:,0] , bins=binsEdges , color='green' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk2 Ch0')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'green' , elinewidth=0.5 , fmt='none' );

y , bins , patches = plt.hist( peakHeight2[:,1] , bins=binsEdges , color='cyan' , histtype = 'step' , log=True , linewidth=2. , label='Height Pk2 Ch1')
plt.errorbar( binCentersFromEdges(bins) , y , yerr = np.sqrt(y) , color = 'cyan' , elinewidth=0.5 , fmt='none' );

plt.ylim(top=6.e4,bottom=0.8)
#plt.xlim(left=1.5,right=1.7)

plt.xlabel('Peak Height (AU)')
plt.ylabel('Counts / bin')
plt.grid()

plt.legend();

f, (ax1, ax2) = plt.subplots(1, 2, figsize = (10,5))

ax1.plot( mu['peakHeight1'][:,0] , mu['peakHeight1'][:,1] , '.' , color='red' , markersize = 0.5 );
ax2.plot( mu['peakHeight2'][:,0] , mu['peakHeight2'][:,1] , 'o' , color='blue' , markersize = 0.5 );


ax1.set_xlabel('Height 1 Ch0 (AU)')
ax1.set_ylabel('Height 1 Ch1 (AU)')
ax1.grid()
ax2.set_xlabel('Height 2 Ch0 (AU)')
ax2.set_ylabel('Height 2 Ch1 (AU)')
ax2.grid()
# plt.legend();

"""## The fitting of time difference between two pulses

The fitting code is very "quick and dirty" - you should use your own code and methods for determining the decay time 
"""

# setup 1 -- coincidence of two main PMTs
both01_cond = (peakWhere2[:,0]!=0) & (peakWhere2[:,1]!=0)

both01 = peakWhere2[:,0][both01_cond]-1.656 #because find_peak2() look for peak after 1.656 s
#both01 = timediff[:,0][both01_cond]
plt.figure(1)
hist, bin_edge, patch = plt.hist(both01, bins = 20, label = 'data', histtype = 'step')

bin_center = (bin_edge[1:]+bin_edge[:-1])/2

bin_center = bin_center[hist!=0]
hist = hist[hist!=0]
print('number of decay events:', sum(hist))

def lifetime(x, a, tau, bkg):
  return a * np.exp(-x/tau) + bkg

x = np.linspace(bin_edge[0], bin_edge[-1], 50)

p0 = np.array([hist[0], 2.2, 10])
popt, pcov = curve_fit(lifetime, bin_center, hist, p0 = p0, sigma = np.sqrt(hist))
fit_result = lifetime(x, *popt)
print(popt, np.sqrt(np.diag(pcov)))

print('lifetime =', round(popt[1], 3), '+-', round(np.sqrt(pcov[1][1]), 3), 'us')


plt.plot(x, fit_result, '--', label = 'fit result', color = 'C1')
# points with error bar
yerr = np.sqrt(hist)
plt.errorbar(bin_center, hist, yerr=yerr, fmt=',', color = 'black')
plt.text(0.77, 0.78, 'Livetime XX hr', transform=plt.gca().transAxes)

plt.xlabel('time [us]')
plt.ylabel('counts')
plt.yscale('log')
plt.legend()

plt.show()

# setup 2-- conincidence with top, anti-coincidence with bottom.
thres = 100
coming_cond = (mu['peakHeight1'][:,0]>thres) & (mu['peakHeight1'][:,1]>thres) & (mu['peakHeight1'][:,2]>thres) & (mu['peakHeight1'][:,3]<thres)
decay_cond = (mu['peakHeight2'][:,0]>thres) & (mu['peakHeight2'][:,1]>thres) &(mu['peakHeight2'][:,2]<thres) & (mu['peakHeight2'][:,3]<thres)
#coming_cond = peakWhere1[:,0] & peakWhere1[:,1] & peakWhere1[:,2] & (peakWhere1[:,3]==0)
#decay_cond = peakWhere2[:,0] & peakWhere2[:,1] &(peakWhere2[:,2]==0) & (peakWhere2[:,3]==0)
both01_cond = coming_cond & decay_cond

both01 = peakWhere2[:,0][both01_cond]-1.656 #because find_peak2() look for peak after 1.656 s
#both01 = timediff[:,0][both01_cond]
plt.figure(1)
hist, bin_edge, patch = plt.hist(both01, bins = 20, label = 'data', histtype = 'step')

bin_center = (bin_edge[1:]+bin_edge[:-1])/2

bin_center = bin_center[hist!=0]
hist = hist[hist!=0]
print('number of decay events:', sum(hist))

def lifetime(x, a, tau, bkg):
  return a * np.exp(-x/tau) + bkg

x = np.linspace(bin_edge[0], bin_edge[-1], 50)

p0 = np.array([hist[0], 2.2, 10])
popt, pcov = curve_fit(lifetime, bin_center, hist, p0 = p0, sigma = np.sqrt(hist))
fit_result = lifetime(x, *popt)
print(popt, np.sqrt(np.diag(pcov)))

print('lifetime =', round(popt[1], 3), '+-', round(np.sqrt(pcov[1][1]), 3), 'us')


plt.plot(x, fit_result, '--', label = 'fit result', color = 'C1')
# points with error bar
yerr = np.sqrt(hist)
plt.errorbar(bin_center, hist, yerr=yerr, fmt=',', color = 'black')
plt.text(0.77, 0.78, 'Livetime XX hr', transform=plt.gca().transAxes)

plt.xlabel('time [us]')
plt.ylabel('counts')
plt.yscale('log')
plt.legend()

plt.show()



"""# Appendix

This notebook is based on a previous notebook which is under more limited access
https://colab.research.google.com/drive/1mnC_xSj3679IePEcICb495fvuDa5y5g_
"""